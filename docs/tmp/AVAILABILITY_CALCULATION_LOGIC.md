# 予約可能時間枠の計算ロジック

## 1. 概要

このドキュメントは、指定された条件（日付、メニュー、スタッフ等）に基づいて、予約可能な時間枠（スロット）を計算するためのバックエンドロジックを定義する。

**注記:** 本ロジックは、主にお客様がオンライン予約を行う際に、予約可能な時間枠を提示するための厳密な計算を定義します。店舗スタッフやオーナーが管理画面から手動で予約を登録する際のバリデーションロジックは、柔軟性を持たせるため、本書とは別に `MANUAL_BOOKING_VALIDATION_LOGIC.md` で定義します。

- **APIエンドポイント**: `GET /api/shops/{shop_slug}/available-slots`
- **目的**: 予約フォームの「日時選択」ステップで、ユーザーに提示する空き時間の一覧を生成する。

---

## 2. 入力パラメータ

| パラメータ名     | 型      | 必須 | 説明                               |
| :--------------- | :------ | :--- | :--------------------------------- |
| `date`           | string  | ✓    | 予約希望日 (YYYY-MM-DD形式)        |
| `menu_id`        | integer | ✓    | 選択されたメニューのID             |
| `option_ids`     | array   |      | 選択されたオプションIDの配列       |
| `requested_staff_id` | integer |      | 顧客が指名したスタッフのID。「指名なし」の場合はNULLまたは未指定。 |

---

## 3. 具体的な出力例

ロジックのイメージを掴むため、具体的なデータに基づいたインプットとアウトプットの例を以下に示す。

### シナリオ設定

**前提データ:**
- **店舗設定:**
  - 予約枠の間隔 (`time_slot_interval`): 30分
- **スタッフAの勤務:**
  - 2025-12-25 の 10:00 から 15:00 まで
- **スタッフBの勤務:**
  - 2025-12-25 の 12:00 から 17:00 まで
- **既存の予約:**
  - スタッフAに 13:00-14:00 の予約が1件 (`assigned_staff_id` = A)
- **メニュー:**
  - **カット (menu_id: 1):** 所要時間60分, `requires_staff_assignment: false` (誰でもOK)
  - **特殊パーマ (menu_id: 2):** 所要時間90分, `requires_staff_assignment: true`, 担当はスタッフBのみ (`menu_staff`に登録済み)

### 出力例

#### シナリオ1：シンプルな「カット」（指名なし）

- **インプット:**
  - `date`: "2025-12-25"
  - `menu_id`: 1 (カット, 60分)
  - `requested_staff_id`: なし
- **アウトプット（JSON）:**
  ```json
  [
    "2025-12-25T10:00:00Z",
    "2025-12-25T10:30:00Z",
    "2025-12-25T11:00:00Z",
    "2025-12-25T11:30:00Z",
    "2025-12-25T12:00:00Z",
    "2025-12-25T14:00:00Z",
    "2025-12-25T15:00:00Z",
    "2025-12-25T15:30:00Z",
    "2025-12-25T16:00:00Z"
  ]
  ```

#### シナリオ2：「カット」をスタッフAで指名

- **インプット:**
  - `date`: "2025-12-25"
  - `menu_id`: 1 (カット, 60分)
  - `requested_staff_id`: A
- **アウトプット（JSON）:**
  ```json
  [
    "2025-12-25T10:00:00Z",
    "2025-12-25T10:30:00Z",
    "2025-12-25T11:00:00Z",
    "2025-12-25T11:30:00Z",
    "2025-12-25T12:00:00Z",
    "2025-12-25T14:00:00Z"
  ]
  ```

#### シナリオ3：「特殊パーマ」（担当者必須メニュー）を指名なし

- **インプット:**
  - `date`: "2025-12-25"
  - `menu_id`: 2 (特殊パーマ, 90分)
  - `requested_staff_id`: なし
- **アウトプット（JSON）:**
  ```json
  [
    "2025-12-25T12:00:00Z",
    "2025-12-25T12:30:00Z",
    "2025-12-25T13:00:00Z",
    "2025-12-25T13:30:00Z",
    "2025-12-25T14:00:00Z",
    "2025-12-25T14:30:00Z",
    "2025-12-25T15:00:00Z",
    "2025-12-25T15:30:00Z"
  ]
  ```

---

## 4. 計算処理フロー

### ステップ1: 合計所要時間の計算

1.  `menus`テーブルから、`menu_id`に対応する`duration`（所要時間）と`requires_staff_assignment`フラグを取得する。
2.  `option_ids`が指定されている場合、`options`テーブルから各オプションの`additional_duration`をすべて取得し、合計する。
3.  メニューの所要時間と、全オプションの所要時間を合算し、**「合計所要時間」**を算出する。

### ステップ2: 対象スタッフの特定

計算の対象となるスタッフのリストを、メニューの担当者要否と顧客の指名の有無に基づいて決定する。

1.  **`requested_staff_id` が指定されている（指名あり）場合:**
    -   そのスタッフを対象とする。(`[requested_staff_id]`)

2.  **`requested_staff_id` が指定されていない（指名なし）場合:**
    -   まず、選択されたメニューの `requires_staff_assignment` フラグを確認する。
    -   **`true` (担当者指定が必須) の場合:**
        -   `menu_staff` テーブルを参照し、その `menu_id` を施術可能な全スタッフを対象とする。
    -   **`false` (担当者指定が不要) の場合:**
        -   その店舗に所属する全てのスタッフを対象とする。

### ステップ3: 勤務スケジュールの取得

1.  対象となる各スタッフについて、`staff_schedules`テーブルから、指定された`date`に該当する勤務スケジュール（`workable_start_at`, `workable_end_at`）をすべて取得する。
2.  **[重要]** 取得した`datetime`値は、必ずそのスケジュールが属する店舗の`shops.timezone`を用いて解釈し、計算処理で利用する際はUTCなどの絶対時刻に変換する。
3.  この時点での勤務時間帯のリストを**「基本勤務時間」**とする。

### ステップ4: 休日の除外

1.  `shop_regular_holidays`テーブルを参照し、指定された`date`の曜日に対応するレコードの `is_closed` フラグが `true` でないか確認する（定休日のチェック）。
2.  `shop_specific_holidays`テーブルから、店舗の特別休業日（特定日）を取得する。
3.  指定された`date`が、定休日または特別休業日に該当する場合、その日は空き時間なし（空の配列を返却）として処理を終了する。
4.  （※将来的には、勤務時間と休日が一部重なるケースも考慮し、基本勤務時間から休日の時間帯を差し引く処理も検討する）

### ステップ5: 予約済み時間帯の取得

1.  対象となる各スタッフについて、`bookings`テーブルから、指定された`date`に該当する予約をすべて取得する。その際、`assigned_staff_id` を見て、誰が実際にその時間を予約されているかを確認する。
2.  **[重要]** 各予約の`start_at`(`datetime`)と`timezone`を組み合わせ、計算処理で利用する際はUTCなどの絶対時刻に変換する。
3.  各予約の絶対時刻と`menu_duration`（および関連する`booking_option`から計算したオプションの所要時間）から、**「予約済み時間帯」**のリストを作成する。

### ステップ6: 空き時間スロットの生成

1.  `shops`テーブルから、予約枠の間隔である`time_slot_interval`（例: 30分）を取得する。
2.  各スタッフの**「基本稼働時間」**から、**「予約済み時間帯」**を引いた、純粋な空き時間帯を算出する。
3.  その空き時間帯を、`time_slot_interval`ごとに区切り、予約候補スロット（開始時刻のリスト）を生成する。

### ステップ7: 各スロットの有効性チェック

生成された各予約候補スロットについて、以下のチェックを行う。

1.  **終了時刻の確認**: `(スロットの開始時刻) + (ステップ1で算出した合計所要時間)`が、次の予約や勤務終了時刻と重ならないか。
2.  **予約締め切り**: `shops`テーブルの`booking_deadline_minutes`を考慮し、締め切り時間を過ぎていないか。

### ステップ8: 最終結果の返却

-   全スタッフの有効な予約スロットをすべて集約し、重複を排除して昇順にソートする。
-   最終的な空き時間枠のリストをJSON形式（ISO 8601文字列の配列）で返却する。�字列の配列）で返却する。