# 画像アップロードガイドライン

## 1. 目的

このドキュメントは、本プロジェクトにおける画像アップロード機能の実装とセキュリティに関するガイドラインを定義します。特に、スタッフプロフィール画像などのユーザーがアップロードするファイルについて、安全性と保守性を確保するための指針を提供します。

## 2. セキュリティ上の考慮事項

ファイルアップロード機能は、Webアプリケーションにおいて最も攻撃を受けやすい機能の一つです。以下の点を常に考慮し、多層的な防御を実装する必要があります。

### 2.1. クライアントサイドとサーバーサイドの役割

-   **クライアントサイド (Vue/Vuetify)**:
    -   **役割**: ユーザー体験の向上（即時フィードバック）。
    -   **限界**: クライアントサイドのチェックは容易に迂回されるため、セキュリティの担保にはなりません。
    -   **実装**: `v-file-input`の`accept`属性（ファイル形式の制限）や`rules`プロパティ（ファイルサイズ制限）を利用します。

-   **サーバーサイド (Laravel)**:
    -   **役割**: **セキュリティの担保**。クライアントサイドのチェックを信頼せず、厳密な検証を必ず行います。
    -   **重要性**: これがシステムの安全性を守る唯一の方法です。

### 2.2. MIMEタイプとファイル内容の検証

-   **MIMEタイプ**: ファイルの拡張子だけでなく、ファイルの中身からMIMEタイプを推測し、許可されたもの（`image/jpeg`など）に限定することが重要です。これにより、`.php`ファイルを`.jpg`に偽装するなどの攻撃を防ぎます。
-   **`getimagesize()`の限界**: PHPの`getimagesize()`関数（Laravelの`image`バリデーションルールが内部で利用）は、ファイルが画像としてのヘッダ構造を持っているかをチェックしますが、**巧妙に作られた画像ファイルに埋め込まれた悪意のあるコードを検出することはできません。** したがって、`getimagesize()`単体でセキュリティを担保することはできません。

## 3. Laravelにおけるベストプラクティス

Laravelの標準機能と信頼できるライブラリを組み合わせることで、堅牢な画像アップロード機能を構築します。

### 3.1. アップロードファイルをドキュメントルート配下に置かない

-   **説明**: アップロードされたファイルをWebサーバーのドキュメントルート（通常`public/`）の外部に保存します。これにより、たとえ悪意のあるスクリプトがアップロードされても、Webサーバーがそれを直接PHPファイルとして実行することを防ぎます。
-   **実現方法**: Laravelの`Storage`ファサードを使用し、`storage/app/public/`のような非公開領域にファイルを保存します。`php artisan storage:link`コマンドで`public/storage`へのシンボリックリンクを作成し、静的ファイルとしてのみ公開します。

### 3.2. ファイル名を付け替える（ユニーク化）

-   **説明**: ユーザーが送信したファイル名をそのまま使用せず、サーバー側で衝突しないユニークなファイル名を生成して保存します。これにより、ディレクトリトラバーサル攻撃や、意図しないファイルの上書き、特定のファイル名に依存する攻撃を防ぎます。
-   **実現方法**: Laravelの`UploadedFile`オブジェクトの`store()`メソッドや、`Str::random()`などのヘルパー関数と組み合わせてユニークなファイル名を生成します。

### 3.3. `intervention/image` を用いた画像のサニタイズ（再エンコード）

-   **説明**: アップロードされた画像を一度メモリ上に読み込み、新しい画像として再エンコードして保存し直します。このプロセスにより、画像データ以外のすべての情報（悪意のあるコード、危険なメタデータなど）が除去され、最も堅牢なセキュリティ対策となります。
-   **実現方法**: `intervention/image`ライブラリを導入し、`Image::make($file)->encode()->save()`のような処理で画像を再生成します。

## 4. 実装例（APIコントローラでの処理フロー）

`Api\Owner\ShopStaffImageController`の`store`メソッドでの処理フロー例です。

1.  **バリデーション**: `FormRequest`を使用して、以下のルールで厳密なサーバーサイドバリデーションを行います。
    -   `required`: ファイルが必須であること。
    -   `file`: アップロードされたものがファイルであること。
    -   `image`: ファイルが有効な画像ファイルであること（`getimagesize()`を含むLaravelの複合的なチェック）。
    -   `mimetypes:image/jpeg,image/png,image/gif`: 許可されたMIMEタイプであること。
    -   `max:2048`: ファイルサイズが2MB以内であること。

2.  **画像のサニタイズとリサイズ**: `intervention/image`を使用して画像をメモリ上で処理します。
    ```php
    use Intervention\Image\Facades\Image;

    $image = Image::make($request->file('image'))
                  ->resize(300, 300, function ($constraint) {
                      $constraint->aspectRatio(); // アスペクト比を維持してリサイズ
                  })
                  ->encode('webp', 80); // 例: WebP形式, 品質80%で再エンコード
    ```

3.  **ユニークなファイル名の生成**: Laravelの`Str::random()`などを使用して、ユニークなファイル名を生成します。
    ```php
    use Illuminate\Support\Str;

    $fileName = Str::random(40) . '.webp'; // 拡張子は再エンコード後のものに合わせる
    $path = 'staff_profiles/' . $fileName;
    ```

4.  **安全な場所への保存**: `Storage`ファサードを使用して、ファイルを非公開領域に保存します。
    ```php
    use Illuminate\Support\Facades\Storage;

    Storage::disk('public')->put($path, (string) $image); // (string) $image で画像データを取得
    ```

5.  **公開URLの生成とDBへの保存**: `Storage::url()`で公開URLを生成し、DBにはこの安全なパス（`$path`）を保存します。
    ```php
    $publicUrl = Storage::url($path);
    // DBに $path を保存
    ```

6.  **レスポンス**: フロントエンドに公開URLやファイルパスをJSONで返します。
    ```json
    {
        "url": "/storage/staff_profiles/xxxxxxxx.webp",
        "path": "staff_profiles/xxxxxxxx.webp"
    }
    ```

このガイドラインに従うことで、安全で堅牢な画像アップロード機能を実現できます。
